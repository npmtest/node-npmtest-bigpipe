{"/home/travis/build/npmtest/node-npmtest-bigpipe/test.js":"/* istanbul instrument in package npmtest_bigpipe */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bigpipe/lib.npmtest_bigpipe.js":"/* istanbul instrument in package npmtest_bigpipe */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bigpipe = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bigpipe = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bigpipe/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bigpipe && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bigpipe */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bigpipe\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bigpipe.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bigpipe.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bigpipe.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bigpipe.__dirname + '/lib.npmtest_bigpipe.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bigpipe/node_modules/bigpipe/index.js":"'use strict';\n\nvar debug = require('diagnostics')('bigpipe:server')\n  , Compiler = require('./lib/compiler')\n  , fabricate = require('fabricator')\n  , Framework = require('bigpipe.js')\n  , destroy = require('demolish')\n  , Zipline = require('zipline')\n  , Temper = require('temper')\n  , Supply = require('supply')\n  , fuse = require('fusing')\n  , async = require('async')\n  , path = require('path');\n\n/**\n * Queryable options with merge and fallback functionality.\n *\n * @param {Object} obj\n * @returns {Function}\n * @api private\n */\nfunction configure(obj) {\n  /**\n   * Get an option.\n   *\n   * @param {String} key Name of the opt\n   * @param {Mixed} backup Fallback data if key does not exist.\n   * @api public\n   */\n  function get(key, backup) {\n    if (key in obj) return obj[key];\n    if (backup !== void 0) obj[key] = backup;\n\n    return obj[key];\n  }\n\n  //\n  // Allow new options to be be merged in against the original object.\n  //\n  get.merge = function merge(properties) {\n    return BigPipe.predefine.merge(obj, properties);\n  };\n\n  return get;\n}\n\n/**\n * Our pagelet management.\n *\n * The following options are available:\n *\n * - cache: A object were we store our URL->pagelet mapping.\n * - dist: The pathname for the compiled assets.\n * - pagelets: String or array of pagelets we serve.\n * - parser: Which parser should be used to send data in real-time.\n * - framework: The framework / fitting we want to use.\n *\n * @constructor\n * @param {Server} server HTTP/S based server instance.\n * @param {Object} options Configuration.\n * @api public\n */\nfunction BigPipe(server, options) {\n  if (!this) return new BigPipe(server, options);\n  this.fuse();\n\n  options = configure(options || {});\n\n  this._pagelets = [];                           // Stores our pagelets.\n  this._server = server;                         // HTTP server we work with.\n  this._options = options;                       // Configure options.\n  this._temper = new Temper;                     // Template parser.\n  this._plugins = Object.create(null);           // Plugin storage.\n  this._cache = options('cache', false);         // Enable URL lookup caching.\n  this._statusCodes = Object.create(null);       // Stores error pagelets.\n  this._zipline = new Zipline(options);          // Improved gzip compression.\n\n  //\n  // Setup the asset compiler before pagelets are discovered as they will\n  // need to hook in to the compiler to register all assets that are loaded.\n  //\n  this._compiler = new Compiler(\n    options('dist', path.join(process.cwd(), 'dist')), this, {\n      pathname: options('static', '/')\n  });\n\n  //\n  // Middleware system, exposed as public so it can\n  // easily be called externally.\n  //\n  this.middleware = new Supply(this);\n  this.initialize(options);\n}\n\n//\n// Inherit from EventEmitter3 as we need to emit listen events etc.\n//\nfuse(BigPipe, require('eventemitter3'));\n\n/**\n * Initialize various things of BigPipe.\n *\n * @param {Object} options Optional options.\n * @returns {BigPipe} Fluent interface.\n * @api private\n */\nBigPipe.readable('initialize', function initialize(options) {\n  //\n  // Add our default middleware layers, this needs to be done before we\n  // initialize or add plugins as we want to make sure that OUR middleware is\n  // loaded first as it's the most important (at least, in our opinion).\n  //\n  this.middleware.use('defaults', require('./middleware/defaults'));\n  this.middleware.use('zipline', this._zipline.middleware());\n  this.middleware.use('compiler', this._compiler.serve);\n\n  //\n  // Provide a evented metrics API, this way users can hook in their metrics\n  // collection modules or easily switch between metrics clients. This gives us\n  // as developers a stable API and our users the flexibility that they require.\n  //\n  this.metrics = options('metrics', {\n    increment: this.emits('metrics:increment'),\n    decrement: this.emits('metrics:decrement'),\n    timing: this.emits('metrics:timing'),\n    gauge: this.emits('metrics:gauge'),\n    set: this.emits('metrics:set')\n  });\n\n  //\n  // Process the Front-end framework abstractions.\n  //\n  this.framework(options('framework', Framework));\n\n  //\n  // Apply the plugins before resolving and transforming the pagelets so the\n  // plugins can hook in to our optimization and transformation process.\n  //\n  return this.pluggable(options('plugins', []));\n});\n\n/**\n * The current version of the library.\n *\n * @type {String}\n * @public\n */\nBigPipe.readable('version', require(__dirname +'/package.json').version);\n\n/**\n * Use a custom framework in BigPipe.\n *\n * @param {Fittings} Framework Framework that we should use.\n * @returns {BigPipe}\n * @api public\n */\nBigPipe.readable('framework', function framework(Framework) {\n  if (this._framework) this._framework.destroy();\n  this._framework = new Framework(this);\n\n  return this;\n});\n\n/**\n * Start listening for incoming requests.\n *\n * @param {Number} port port to listen on\n * @param {Function} done callback\n * @return {BigPipe} fluent interface\n * @api public\n */\nBigPipe.readable('listen', function listen(port, done) {\n  var pagelets = this._options('pagelets', path.join(process.cwd(), 'pagelets'))\n    , bigpipe = this;\n\n  //\n  // Make sure we should only start listening on the server once\n  // we're actually ready to respond to requests.\n  //\n  this.define(pagelets, function defined(err) {\n    if (err) {\n      debug('I failed to listen to the server due to', err.stack);\n\n      if (done) return done(err);\n      return bigpipe.emit('error', err);\n    }\n\n    bigpipe._server.on('listening', bigpipe.emits('listening'));\n    bigpipe._server.on('request', bigpipe.bind(bigpipe.dispatch));\n    bigpipe._server.on('error', bigpipe.emits('error'));\n\n    //\n    // Start listening on the provided port and return the BigPipe instance.\n    //\n    debug('Succesfully defined pagelets and assets, starting HTTP server on port %d', port);\n    bigpipe._server.listen(port, done);\n  });\n\n  return bigpipe;\n});\n\n/**\n * Discover if the user supplied us with custom error pagelets so we use that\n * in case we need to handle a 404 or and 500 errors.\n *\n * @param {Function} done Completion callback.\n * @returns {BigPipe} fluent interface\n * @api private\n */\nBigPipe.readable('discover', function discover(done) {\n  var local = ['404', '500', 'bootstrap']\n    , bigpipe = this\n    , childs = [];\n\n  debug('Discovering build-in pagelets, filtering out defaults (404, 500, bootstrap)');\n  bigpipe._pagelets = bigpipe._pagelets.filter(function filter(Pagelet) {\n    var router = Pagelet.router\n      , parent = !Pagelet.prototype._parent;\n\n    //\n    // Crawl all the children for potential routes.\n    //\n    Pagelet.prototype._children.forEach(function eachChild(pagelet) {\n      pagelet = filter(pagelet[0]);\n      if (pagelet) childs.push(pagelet);\n    });\n\n    //\n    // Extract 404, 500 and bootstrap pagelets.\n    //\n    if (parent && router && router.test('/404')) local[0] = Pagelet;\n    else if (parent && router && router.test('/500')) local[1] = Pagelet;\n    else if (parent && Pagelet.prototype.name === 'bootstrap') local[2] = Pagelet;\n    else if (router) return Pagelet;\n  }).concat(childs);\n\n  async.map(local, function (Pagelet, next) {\n    if ('string' !== typeof Pagelet) return next(undefined, Pagelet);\n\n    debug('No %s pagelet detected, using default bigpipe %s pagelet', Pagelet, Pagelet);\n    require(Pagelet + '-pagelet').optimize({\n      bigpipe: bigpipe,\n      transform: {\n        before: bigpipe.emits('transform:pagelet:before'),\n        after: bigpipe.emits('transform:pagelet:after')\n      }\n    }, next);\n  }, function found(error, status) {\n    if (error) return done(error);\n\n    bigpipe._statusCodes[404] = status[0];\n    bigpipe._statusCodes[500] = status[1];\n    bigpipe._bootstrap = status[2];\n\n    //\n    // Also catalog dependencies on status Pagelets and bootstrap.\n    // As the developer could have provided custom Pagelets.\n    //\n    bigpipe._compiler.catalog(bigpipe._pagelets.concat(status), done);\n  });\n\n  return this;\n});\n\n/**\n * Render a pagelet from our `statusCodes` collection.\n *\n * @param {Pagelet} pagelet Reference to pagelet that invoked status.\n * @param {Number} code The status we should handle.\n * @param {Mixed} data Nothing or something, usually an Error\n * @returns {Pagelet} Generated status pagelet.\n * @api private\n */\nBigPipe.readable('status', function status(pagelet, code, data, bootstrap) {\n  if (!(code in this._statusCodes)) {\n    return this.emit('error', new Error('Unsupported HTTP code: '+ code +'.'));\n  }\n\n  //\n  // No need to do a complete bootstrap of the pagelet, only return\n  // the status code Pagelet, where the name is replaced with the Pagelet\n  // that received the error.\n  //\n  if (!bootstrap) return new this._statusCodes[code]({\n    bootstrap: pagelet.bootstrap,\n    parent: pagelet._parent,\n    req: pagelet._req,\n    res: pagelet._res,\n    bigpipe: this\n  }, data, pagelet.name);\n\n  //\n  // Do a full initialization of the status code Pagelet.\n  //\n  this.bootstrap(new this._statusCodes[code]({\n    parent: 'bootstrap',\n    req: pagelet._req,\n    res: pagelet._res,\n    bigpipe: this\n  }, data));\n});\n\n/**\n * Insert pagelet into collection of pagelets. If pagelet is a manually\n * instantiated Pagelet push it in, otherwise resolve the path, always\n * transform the pagelet. After dependencies are catalogued the callback\n * will be called.\n *\n * @param {Mixed} pagelets array of composed Pagelet objects or file path.\n * @param {Function} done callback\n * @api public\n */\nBigPipe.readable('define', function define(pagelets, done) {\n  var bigpipe = this;\n\n  async.map(fabricate(pagelets), function map(Pagelet, next) {\n    if ('function' !== typeof Pagelet.optimize) return next();\n\n    Pagelet.optimize({\n      bigpipe: bigpipe,\n      transform: {\n        before: bigpipe.emits('transform:pagelet:before'),\n        after: bigpipe.emits('transform:pagelet:after')\n      }\n    }, next);\n  }, function fabricated(err, pagelets) {\n    if (err) return done(err);\n\n    bigpipe._pagelets.push.apply(bigpipe._pagelets, pagelets.filter(Boolean));\n    bigpipe.discover(done);\n  });\n\n  return this;\n});\n\n/**\n * Bind performance is horrible. This introduces an extra function call but can\n * be heavily optimized by the V8 engine. Only use this in cases where you would\n * normally use `.bind`.\n *\n * @param {Function} fn A method of bigpipe.\n * @returns {Function}\n * @api private\n */\nBigPipe.readable('bind', function bind(fn) {\n  var bigpipe = this;\n\n  return function bound(arg1, arg2, arg3) {\n    fn.call(bigpipe, arg1, arg2, arg3);\n  };\n});\n\n/**\n * Find and initialize pagelets based on a given id or on the pathname of the\n * request.\n *\n * @param {HTTP.Request} req The incoming HTTP request.\n * @param {HTTP.Response} res The outgoing HTTP request.\n * @param {String} id Optional id of pagelet we specifically need.\n * @api private\n */\nBigPipe.readable('router', function router(req, res, id) {\n  var key = id ? id : req.method +'@'+ req.uri.pathname\n    , cache = this._cache ? this._cache.get(key) || [] : []\n    , pagelets = this._pagelets\n    , length = pagelets.length\n    , bigpipe = this\n    , i = 0\n    , pagelet;\n\n  //\n  // Cache is empty.\n  //\n  if (!cache.length) {\n    if (id) for (; i < length; i++) {\n      pagelet = pagelets[i];\n\n      if (id === pagelet.prototype.id) {\n        cache.push(pagelet);\n        break;\n      }\n    } else for (; i < length; i++) {\n      pagelet = pagelets[i];\n\n      if (!pagelet.router.test(req.uri.pathname)) continue;\n      if (pagelet.method.length && !~pagelet.method.indexOf(req.method)) continue;\n\n      cache.push(pagelet);\n    }\n\n    if (this._cache && cache.length) {\n      this._cache.set(key, cache);\n      debug('Added key %s and its found pagelets to our internal lookup cache', key);\n    }\n  }\n\n  //\n  // Add an extra 404 pagelet so we always have a pagelet to display.\n  //\n  cache.push(this._statusCodes[404]);\n\n  //\n  // It could be that we have selected a couple of authorized pagelets. Filter\n  // those out before sending the initialized pagelet to the callback.\n  //\n  (function each(pagelets) {\n    var Pagelet = pagelets.shift()\n      , pagelet = new Pagelet({\n          params: Pagelet.router.exec(req.uri.pathname),\n          parent: 'bootstrap',\n          bigpipe: bigpipe,\n          append: true,\n          req: req,\n          res: res\n        });\n\n    debug('Iterating over pagelets for %s testing %s atm', req.url, pagelet.path);\n\n    //\n    // Check if the parent Pagelet is authorized or not. If the Pagelet is\n    // not allowed, continue crawling the other routable pagelets.\n    //\n    if (pagelet.if) {\n      return pagelet.conditional(req, function authorize(allowed) {\n        debug(\n          'Authorization %s for %s',\n          allowed ? 'allowed' : 'disallowed',\n          pagelet.path\n        );\n\n        if (allowed) return bigpipe.bootstrap(pagelet, req, res);\n        each(pagelets);\n      });\n    }\n\n    debug('Using %s for %s', pagelet.path, req.url);\n    bigpipe.bootstrap(pagelet, req, res);\n  }(cache.slice(0)));\n\n  return this;\n});\n\n/**\n * Run the plugins.\n *\n * @param {Array} plugins List of plugins.\n * @returns {BigPipe} fluent interface\n * @api private\n */\nBigPipe.readable('pluggable', function pluggable(plugins) {\n  var bigpipe = this;\n\n  plugins.forEach(function plug(plugin) {\n    bigpipe.use(plugin);\n  });\n\n  return this;\n});\n\n/**\n * Dispatch incoming requests.\n *\n * @param {Request} req HTTP request.\n * @param {Response} res HTTP response.\n * @returns {BigPipe} fluent interface\n * @api private\n */\nBigPipe.readable('dispatch', function dispatch(req, res) {\n  var bigpipe = this;\n\n  return this.middleware.each(req, res, function next(error, early) {\n    if (error) return bigpipe.status({ _req: req, _res: res}, 500, error, true);\n    if (early) return debug('request was handled by a middleware layer');\n\n    bigpipe.router(req, res);\n  });\n});\n\n/**\n * Register a new plugin.\n *\n * ```js\n * bigpipe.use('ack', {\n *   //\n *   // Only ran on the server.\n *   //\n *   server: function (bigpipe, options) {\n *      // do stuff\n *   },\n *\n *   //\n *   // Runs on the client, it's automatically bundled.\n *   //\n *   client: function (bigpipe, options) {\n *      // do client stuff\n *   },\n *\n *   //\n *   // Optional library that needs to be bundled on the client. The library\n *   // should be an object having a `path` and `name` property.\n *   //\n *   library: {\n *     path: '/path/to/library',\n *     name: 'name'\n *   },\n *\n *   //\n *   // Optional plugin specific options, will be merged with Bigpipe.options\n *   //\n *   options: {}\n * });\n * ```\n *\n * @param {String} name The name of the plugin.\n * @param {Object} plugin The plugin that contains client and server extensions.\n * @api public\n */\nBigPipe.readable('use', function use(name, plugin) {\n  if ('object' === typeof name) {\n    plugin = name;\n    name = plugin.name;\n  }\n\n  if (!name) throw new Error('Plugin should be specified with a name.');\n  if ('string' !== typeof name) throw new Error('Plugin names should be a string.');\n  if ('string' === typeof plugin) plugin = require(plugin);\n\n  //\n  // Plugin accepts an object or a function only.\n  //\n  if (!/^(object|function)$/.test(typeof plugin)) {\n    throw new Error('Plugin should be an object or function.');\n  }\n\n  //\n  // Plugin require a client, server or both to be specified in the object.\n  //\n  if (!('server' in plugin || 'client' in plugin)) {\n    throw new Error('The plugin is missing a client or server function.');\n  }\n\n  if (name in this._plugins) {\n    throw new Error('The plugin name was already defined. Please select an unique name for each plugin');\n  }\n\n  //\n  // Resolve the path of the plugin as it might be required\n  // to resolve dependencies.\n  //\n  Object.keys(require.cache).forEach(function (key) {\n    if (require.cache[key].exports !== plugin) return;\n    plugin.path = key;\n  });\n\n  debug('Added plugin `%s`', name);\n\n  this._plugins[name] = plugin;\n  if (!plugin.server) return this;\n\n  this._options.merge(plugin.options || {});\n  plugin.server.call(this, this, this._options);\n\n  return this;\n});\n\n/**\n * Redirect the user.\n *\n * @param {String} location Where should we redirect to.\n * @param {Number} status The status number.\n * @api public\n */\nBigPipe.readable('redirect', function redirect(pagelet, location, status, options) {\n  options = options || {};\n\n  pagelet._res.statusCode = +status || 301;\n  pagelet._res.setHeader('Location', location);\n\n  //\n  // Instruct browsers to not cache the redirect.\n  //\n  if (options.cache === false) {\n    pagelet._res.setHeader('Pragma', 'no-cache');\n    pagelet._res.setHeader('Expires', 'Sat, 26 Jul 1997 05:00:00 GMT');\n    pagelet._res.setHeader('Cache-Control', [\n      'no-store', 'no-cache', 'must-revalidate', 'post-check=0', 'pre-check=0'\n    ].join(', '));\n  }\n\n  pagelet._res.end();\n\n  if (pagelet.listeners('end').length) pagelet.emit('end');\n  return pagelet.debug('Redirecting to %s', location);\n});\n\n/**\n * Initialize a new Bootstrap Pagelet and return it so the routed Pagelet and\n * its childs can use it as state keeper. The HTML of the bootstrap pagelet is\n * flushed asap to the client.\n *\n * @param {Pagelet} child Pagelet that was found by the Router.\n * @param {ServerRequest} req HTTP server request.\n * @param {ServerResponse} res HTTP server response.\n * @returns {Bootstrap} Bootstrap Pagelet.\n * @api private\n */\nBigPipe.readable('bootstrap', function bootstrap(child, req, res) {\n  req = req || child._req;\n  res = res || child._res;\n\n  //\n  // It could be that the initialization handled the page rendering through\n  // a `page.redirect()` or a `page.notFound()` call so we should terminate\n  // the request once that happens.\n  //\n  if (res.finished) return this;\n\n  //\n  // @TODO rel prefetch for resources that are used on the next page?\n  // @TODO cache manifest.\n  //\n  res.statusCode = child.statusCode;\n\n  //\n  // If we have a `no_pagelet_js` flag, we should force a different\n  // rendering mode. This parameter is automatically added when we've\n  // detected that someone is browsing the site without JavaScript enabled.\n  //\n  // In addition to that, the other render modes only work if your browser\n  // supports trailing headers which where introduced in HTTP 1.1 so we need\n  // to make sure that this is something that the browser understands.\n  // Instead of checking just for `1.1` we want to make sure that it just\n  // tests for every http version above 1.0 as http 2.0 is just around the\n  // corner.\n  //\n  if (\n       'no_pagelet_js' in req.query && +req.query.no_pagelet_js === 1\n    || !(req.httpVersionMajor >= 1 && req.httpVersionMinor >= 1)\n  ) {\n    child.debug('Forcing `sync` instead of %s due lack of HTTP 1.1 or JS', child.mode);\n    child.mode = 'sync';\n  }\n\n  //\n  // Create a bootstrap Pagelet, this is a special Pagelet that is flushed\n  // as soon as possible to instantiate the client side rendering.\n  //\n  child.bootstrap = new this._bootstrap({\n    dependencies: this._compiler.page(child),\n    params: child._params,\n    length: child.length,\n    child: child.name,\n    mode: child.mode,\n    bigpipe: this,\n    res: res,\n    req: req\n  });\n\n  this.emit('bootstrap', child, req, res);\n\n  if (child.initialize) {\n    if (child.initialize.length) {\n      child.debug('Waiting for `initialize` method before rendering');\n      child.initialize(child.init.bind(child));\n    } else {\n      child.initialize();\n      child.init();\n    }\n  } else {\n    child.init();\n  }\n\n  return this;\n});\n\n/**\n * Mode: Synchronous\n * Output the pagelets fully rendered in the HTML template.\n *\n * @TODO remove pagelet's that have `authorized` set to `false`\n * @TODO Also write the CSS and JavaScript.\n *\n * @param {Pagelet} pagelet Parent pagelet\n * @api private\n */\nBigPipe.readable('sync', function synchronous(pagelet) {\n  var bigpipe = this\n    , pagelets;\n\n  //\n  // Because we're synchronously rendering the pagelets we need to discover\n  // which one's are enabled before we send the bootstrap code so it can include\n  // the CSS files of the enabled pagelets in the HEAD of the page so there is\n  // styling available.\n  //\n  pagelet.bootstrap.render();\n  pagelet.once('discover', function discovered() {\n    pagelet.debug('Processing the pagelets in `sync` mode');\n\n    pagelets = pagelet._enabled.concat(pagelet._disabled, pagelet);\n    async.each(pagelets, function render(child, next) {\n      pagelet.debug('Invoking pagelet %s/%s render', child.name, child.id);\n\n      child.render({ mode: 'sync' }, function rendered(error, content) {\n        if (error) return render(bigpipe.capture(error), next);\n\n        child.write(content);\n        next();\n      });\n    }, function done() {\n      pagelet.bootstrap.reduce().end();\n    });\n  }).discover();\n});\n\n/**\n * Mode: Asynchronous\n * Output the pagelets as fast as possible.\n *\n * @param {Pagelet} pagelet Parent pagelet\n * @api private\n */\nBigPipe.readable('async', function asynchronous(pagelet) {\n  var bigpipe = this\n    , pagelets;\n\n  //\n  // Flush the initial headers asap so the browser can start detect encoding\n  // start downloading assets and prepare for rendering additional pagelets.\n  //\n  pagelet.bootstrap.render().flush(function headers(error) {\n    if (error) return bigpipe.capture(error, pagelet, true);\n\n    pagelet.once('discover', function discovered() {\n      pagelet.debug('Processing the pagelets in `async` mode');\n\n      pagelets = pagelet._enabled.concat(pagelet._disabled, pagelet);\n      async.each(pagelets, function render(child, next) {\n        pagelet.debug('Invoking pagelet %s/%s render', child.name, child.id);\n\n        child.render({\n          data: bigpipe._compiler.pagelet(child)\n        }, function rendered(error, content) {\n          if (error) return render(bigpipe.capture(error), child, next);\n          child.write(content).flush(next);\n        });\n      }, function done(error) {\n        if (error) return bigpipe.capture(error);\n        pagelet.end();\n      });\n    }).discover();\n  });\n});\n\n/**\n * Mode: pipeline\n * Output the pagelets as fast as possible but in order.\n *\n * @param {Pagelet} pagelet Parent pagelet\n * @api private\n */\nBigPipe.readable('pipeline', function pipeline(pagelet) {\n  var bigpipe = this\n    , pagelets;\n\n  //\n  // Flush the initial headers asap so the browser can start detect encoding\n  // start downloading assets and prepare for rendering additional pagelets.\n  //\n  pagelet.bootstrap.render().flush(function headers(error) {\n    if (error) return bigpipe.capture(error, pagelet, true);\n\n    pagelet.once('discover', function discovered() {\n      pagelet.debug('Processing the pagelets in `async` mode');\n\n      //\n      // Concat pagelets and provide order through the pagelet id.\n      //\n      pagelets = pagelet._enabled\n        .concat(pagelet._disabled, pagelet)\n        .sort(function sortByPageletId(a, b) {\n          if (a.id < b.id) return -1;\n          if (a.id > b.id) return 1;\n          return 0;\n        });\n\n      //\n      // Keep track of the order of pagelets through their id. Asynchronous\n      // render all the different pagelets, but only write and flush in the\n      // order that was set by sort.\n      //\n      var order = pagelets.map(function returnId(pagelet) { return pagelet.id; })\n        , output = []\n        , i = 0;\n\n      async.each(pagelets, function render(child, next) {\n        pagelet.debug('Invoking pagelet %s/%s render', child.name, child.id);\n\n        child.render({\n          data: bigpipe._compiler.pagelet(child)\n        }, function rendered(error, content) {\n          if (error) return render(bigpipe.capture(error), child, next);\n          output[order.indexOf(child.id)] = content;\n\n          for (; i < output.length; i++) {\n            if (!output[i]) return next();\n            child.write(output[i]).flush();\n          }\n\n          next();\n        });\n      }, function done(error) {\n        if (error) return bigpipe.capture(error);\n        pagelet.end();\n      });\n    }).discover();\n  });\n});\n\n/**\n * We've received an error. Close down pagelet and display a 500 error Pagelet.\n *\n * @TODO handle the case when we've already flushed the initial bootstrap code\n * to the client and we're presented with an error.\n *\n * @param {Error} error Optional error argument to trigger the error pagelet.\n * @param {Pagelet} pagelet Reference to the pagelet that triggered the error.\n * @param {Boolean} bootstrap Do full bootstrap if true.\n * @returns {BigPipe} fluent interface.\n * @api private\n */\nBigPipe.readable('capture', function capture(error, pagelet, bootstrap) {\n  debug(\n    'Captured an error from %s: %s, displaying error pagelet',\n    pagelet.name,\n    error\n  );\n\n  return this.status(pagelet, 500, error, bootstrap || false);\n});\n\n/**\n * Completely destroy the instance and remove/release all its references.\n *\n * @type {Function}\n * @api public\n */\nBigPipe.readable('destroy', destroy([\n  '_pagelets', '_server', '_options', '_temper', '_plugins', '_cache',\n  '_statusCodes', '_zipline', '_compiler', 'middleware'\n], {\n  before: function before() {\n    try { this._server.close(); }\n    catch (e) {}\n  },\n  after: 'removeAllListeners'\n}));\n\n/**\n * Create a new Pagelet/BigPipe server.\n *\n * @param {Number} port port to listen on\n * @param {Object} options Configuration.\n * @returns {BigPipe}\n * @api public\n */\nBigPipe.createServer = function createServer(port, options) {\n  options = 'object' === typeof port ? port : options || {};\n  if ('number' === typeof port || 'string' === typeof port) options.port = +port;\n\n  var listen = options.listen === false\n    , bigpipe;\n\n  //\n  // Listening is done by our own .listen method, so we need to tell the\n  // createServer module that we don't want it to start listening to our sizzle.\n  // This option is forced and should not be override by users configuration.\n  //\n  options.listen = false;\n  options.port = options.port || 8080;\n  bigpipe = new BigPipe(require('create-server')(options), options);\n\n  //\n  // By default the server will listen. Passing options.listen === false\n  // is only required if listening needs to be done with a manual call.\n  // BigPipe.createServer will pass as argument.\n  //\n  return listen ? bigpipe : bigpipe.listen(options.port);\n};\n\n//\n// Expose the constructor.\n//\nmodule.exports = BigPipe;\n","/home/travis/build/npmtest/node-npmtest-bigpipe/node_modules/bigpipe/lib/compiler.js":"'use strict';\n\nvar debug = require('diagnostics')('bigpipe:compiler')\n  , Collection = require('./collection')\n  , browserify = require('browserify')\n  , preprocess = require('smithy')\n  , mkdirp = require('mkdirp')\n  , crypto = require('crypto')\n  , stream = require('stream')\n  , async = require('async')\n  , File = require('./file')\n  , path = require('path')\n  , fs = require('fs');\n\n/**\n * Small extension of a Readable Stream to push content into the browserify build.\n *\n * @Constructor\n * @param {Mixed} str file content\n * @api private\n */\nfunction Content(str) {\n  stream.Readable.call(this);\n\n  this.push(Array.isArray(str) ? str.join('') : str);\n  this.push(null);\n}\n\n//\n// Inherit from Readable Stream and provide a _read stub.\n//\nrequire('util').inherits(Content, stream.Readable);\nContent.prototype._read = function noop () {};\n\n/**\n * Asset compiler and management.\n *\n * @constructor\n * @param {String} directory The directory where we save our static files.\n * @param {Pipe} pipe The configured Pipe instance.\n * @param {Object} options Configuration.\n * @api private\n */\nfunction Compiler(directory, pipe, options) {\n  options = options || {};\n  this.pipe = pipe;\n\n  // The namespace where we can download files.\n  this.pathname = options.pathname || '/';\n\n  // Directory to save the compiled files.\n  this.dir = directory;\n\n  // List of pre-compiled or previous compiled files.\n  this.list = [];\n\n  // Contains template engines that are used to render.\n  this.core = [];\n\n  this.buffer = Object.create(null); // Precompiled asset cache\n  this.alias = Object.create(null);  // Path aliases.\n\n  //\n  // Create the provided directory, will short circuit if present.\n  //\n  mkdirp.sync(directory);\n}\n\nCompiler.prototype.__proto__ = require('eventemitter3').prototype;\nCompiler.prototype.asyncemit = require('asyncemit');\n\n/**\n * Create the BigPipe base front-end framework that's required for the handling\n * of the real-time connections and the initialization of the arriving pagelets.\n *\n * @param {Function} done Completion callback.\n * @api private\n */\nCompiler.prototype.bigPipe = function bigPipe(done) {\n  var framework = this.pipe._framework\n    , library\n    , plugin\n    , name\n    , file;\n\n  debug('Creating the bigpipe.js front-end library');\n\n  library = browserify();\n  framework.get('library').forEach(function each(file) {\n    library.require(file.path, { expose: file.expose });\n  });\n\n  if (this.core.length) library.require(new Content(this.core));\n\n  for (name in this.pipe._plugins) {\n    plugin = this.pipe._plugins[name];\n\n    if (plugin.library) {\n      library.require(plugin.library.path, { expose: plugin.library.name });\n    }\n\n    if (!plugin.client || !plugin.path) continue;\n    debug('Adding the client code of the %s plugin to the client file', name);\n\n    library.require(new Content(framework.get('plugin', {\n      client: plugin.client.toString(),\n      name: name\n    })), { file: plugin.path, entry: true });\n  }\n\n  library.bundle(done);\n};\n\n/**\n * Merge in objects.\n *\n * @param {Object} target The object that receives the props\n * @param {Object} additional Extra object that needs to be merged in the target\n * @api private\n */\nCompiler.prototype.merge = function merge(target, additional) {\n  var result = target\n    , compiler = this;\n\n  if (Array.isArray(target)) {\n    compiler.forEach(additional, function arrayForEach(index) {\n      if (JSON.stringify(target).indexOf(JSON.stringify(additional[index])) === -1) {\n        result.push(additional[index]);\n      }\n    });\n  } else if ('object' === typeof target) {\n    compiler.forEach(additional, function objectForEach(key, value) {\n      if (target[key] === void 0) {\n        result[key] = value;\n      } else {\n        result[key] = compiler.merge(target[key], additional[key]);\n      }\n    });\n  } else {\n    result = additional;\n  }\n\n  return result;\n};\n\n/**\n * Iterate over a collection. When you return false, it will stop the iteration.\n *\n * @param {Mixed} collection Either an Array or Object.\n * @param {Function} iterator Function to be called for each item\n * @api private\n */\nCompiler.prototype.forEach = function forEach(collection, iterator, context) {\n  if (arguments.length === 1) {\n    iterator = collection;\n    collection = this;\n  }\n\n  var isArray = Array.isArray(collection || this)\n    , length = collection.length\n    , i = 0\n    , value;\n\n  if (context) {\n    if (isArray) {\n      for (; i < length; i++) {\n        value = iterator.apply(collection[i], context);\n        if (value === false) break;\n      }\n    } else {\n      for (i in collection) {\n        value = iterator.apply(collection[i], context);\n        if (value === false) break;\n      }\n    }\n  } else {\n    if (isArray) {\n      for (; i < length; i++) {\n        value = iterator.call(collection[i], i, collection[i]);\n        if (value === false) break;\n      }\n    } else {\n      for (i in collection) {\n        value = iterator.call(collection[i], i, collection[i]);\n        if (value === false) break;\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Get the processed extension for a certain file.\n *\n * @param {String} filepath full path to file\n * @api public\n */\nCompiler.prototype.type = function type(filepath) {\n  var processor = this.processor(filepath);\n  return processor ? '.' + processor.export : path.extname(filepath);\n};\n\n/**\n * Get preprocessor.\n *\n * @param {String} filepath\n * @returns {Function}\n * @api public\n */\nCompiler.prototype.processor = function processor(filepath) {\n  return preprocess[path.extname(filepath).substr(1)];\n};\n\n/**\n * Upsert new file in compiler cache.\n *\n * @param {String} filepath full path to file\n * @api private\n */\nCompiler.prototype.put = function put(filepath) {\n  var compiler = this;\n\n  compiler.process(filepath, function processed(error, code) {\n    if (error) return compiler.emit('error', error);\n\n    compiler.emit('preprocessed', filepath);\n    compiler.register(new File(filepath, {\n      extname: compiler.type(filepath),\n      code: code\n    }));\n  });\n};\n\n/**\n * Read the file from disk and preprocess it depending on extension.\n *\n * @param {String} filepath full path to file\n * @param {Function} fn callback\n * @api private\n */\nCompiler.prototype.process = function process(filepath, fn) {\n  var processor = this.processor(filepath)\n    , paths = [ path.dirname(filepath) ];\n\n  fs.readFile(filepath, 'utf-8', function read(error, code) {\n    if (error || !processor) return fn(error, code);\n\n    //\n    // Only preprocess the file if required.\n    //\n    processor(code, { location: filepath, paths: paths }, fn);\n  });\n};\n\n/**\n * Prefix selectors of CSS with [data-pagelet='name'] to contain CSS to\n * specific pagelets. File can have the following properties.\n *\n * @param {File} file instance of File\n * @param {Function} fn completion callback.\n * @api public\n */\nCompiler.prototype.namespace = function prefix(file, fn) {\n  //\n  // Only prefix if the code is CSS content and not a page dependency.\n  //\n  if (!file.is('css') || file.dependency) return fn(null, file);\n  debug('namespacing %s to pagelets %s', file.hash, file.pagelets);\n\n  var processor = preprocess.css\n    , options = {}\n    , pagelets;\n\n  //\n  // Transform the pagelets names to data selectors.\n  //\n  pagelets = file.pagelets.map(function prepare(pagelet) {\n    return '[data-pagelet=\"'+ pagelet +'\"]';\n  });\n\n  options.plugins = [ processor.plugins.namespace(pagelets) ];\n  processor(file.code, options, function done(error, code) {\n    if (error) return fn(error);\n    fn(null, file.set(code, true));\n  });\n};\n\n/**\n * Register a new library with the compiler. The following traits can be\n * provided to register a specific file.\n *\n * @param {File} file instance of File.\n * @param {Boolean} origin Flag to store file with original filepath as reference.\n * @api private\n */\nCompiler.prototype.register = function register(file, origin) {\n  if (!file.length) return debug('Skipped registering empty file %j', file.aliases);\n  var compiler = this;\n\n  //\n  // Add file to the buffer collection.\n  //\n  this.buffer[origin ? file.origin : file.location] = file;\n\n  //\n  // Add file references to alias.\n  //\n  file.aliases.forEach(function add(alias) {\n    if (!alias) return;\n\n    this.alias[alias] = file.location;\n  }, this);\n\n  this.asyncemit('register', file, function (error) {\n    if (error) return compiler.emit('error', error);\n    compiler.save(file);\n  });\n};\n\n/**\n * Catalog the pages. As we're not caching the file look ups, this method can be\n * called when a file changes so we will generate new.\n *\n * @param {Array} pages The array of pages.\n * @param {Function} done callback\n * @api private\n */\nCompiler.prototype.catalog = function catalog(pages, done) {\n  var framework = this.pipe._framework\n    , temper = this.pipe._temper\n    , core = this.core\n    , compiler = this\n    , list = {};\n\n  /**\n   * Process the dependencies.\n   *\n   * @param {Object} assemble generated collection of file properties.\n   * @param {String} filepath The location of a file.\n   * @param {Function} next completion callback.\n   * @api private\n   */\n  function prefab(assemble, filepath, next) {\n    if (compiler.http(filepath)) return next(null, assemble);\n\n    compiler.process(filepath, function store(error, code) {\n      if (error) return next(error);\n\n      var file = new File(filepath, {\n        extname: compiler.type(filepath),\n        dependency: list[filepath].dependency,\n        code: code\n      });\n\n      file = file.hash in assemble ? assemble[file.hash] : file;\n      file.pagelets = (file.pagelets || []).concat(list[filepath].pagelets);\n      file.alias(filepath);\n\n      assemble[file.hash] = file;\n      debug('finished pre-processing %s to hash %s', path.basename(filepath), file.hash);\n      next(null, assemble);\n    });\n  }\n\n  /**\n   * Register the files in the assembly, prefix CSS first.\n   *\n   * @param {Object} assemble generated collection of file properties.\n   * @param {Function} next completion callback.\n   * @api private\n   */\n  function register(assemble, next) {\n    async.each(Object.keys(assemble), function prefix(hash, fn) {\n      compiler.asyncemit('assembly', assemble[hash], function (err) {\n        if (err) return fn(err);\n\n        compiler.register(assemble[hash]);\n        fn();\n      });\n    }, next);\n  }\n\n  //\n  // Check all pages for dependencies and files to add to the list.\n  //\n  pages.forEach(function each(Page) {\n    var page = Page.prototype\n      , dependencies = Array.isArray(page.dependencies) ? page.dependencies : [];\n\n    /**\n     * Add files to the process list.\n     *\n     * @param {String} name Pagelet name.\n     * @param {String|Array} files Path to files.\n     * @param {Boolean} dependency Push this file to global dependencies.\n     * @api private\n     */\n    function add(name, files, dependency) {\n      //\n      // Check if files is an object and return, this Pagelet has already\n      // been cataloged and the dependencies overwritten.\n      //\n      if ('object' === typeof files && !Array.isArray(files)) return;\n      files = Array.isArray(files) ? files : [ files ];\n      files.forEach(function loopFiles(file) {\n        if (dependency && !~dependencies.indexOf(file)) dependencies.push(file);\n\n        //\n        // Use stored file or create a new one based on the filepath.\n        //\n        file = list[file] = list[file] || { dependency: false, pagelets: [] };\n        if (name && !~file.pagelets.indexOf(name)) file.pagelets.push(name);\n        if (dependency) file.dependency = true;\n      });\n    }\n\n    /**\n     * Register a new view.\n     *\n     * @param {String} path Location of the template file\n     * @param {String} error\n     * @api private\n     */\n    function view(page, type) {\n      var path = page[type]\n        , data;\n\n      debug('Attempting to compile the view %s', path);\n      data = temper.fetch(path);\n\n      //\n      // The views can be rendered on the client, but some of them require\n      // a library, this library should be cached in the core library.\n      //\n      if (data.library && !~core.indexOf(data.library)) {\n        core.push(data.library);\n      }\n\n      if (!data.hash) data.hash = {\n        client: crypto.createHash('md5').update(data.client).digest('hex')\n      };\n\n      compiler.register(new File(path, {\n        extname: '.js',\n        code: framework.get('template', {\n          name: data.hash.client,\n          client: data.client\n        })\n      }));\n    }\n\n    //\n    // Note: quick fix, now that routed pages have become pagelets\n    // we should also resolve the Page assets.\n    //\n    page._children.concat(Page).forEach(function each(Pagelet) {\n      if (Array.isArray(Pagelet)) return Pagelet.forEach(each);\n\n      var pagelet = Pagelet.prototype;\n\n      if (pagelet.js) add(pagelet.name, pagelet.js);\n      if (pagelet.css) add(pagelet.name, pagelet.css);\n\n      add(pagelet.name, pagelet.dependencies, true);\n\n      if (pagelet.view) view(pagelet, 'view');\n      if (pagelet.error) view(pagelet, 'error');\n    });\n\n    //\n    // Store the page level dependencies per file extension in the page.\n    // If the file extension cannot be determined, the dependency will be tagged\n    // as foreign, so other functions like `html` and `page` can do additional\n    // checks to include the file.\n    //\n    page._dependencies = dependencies.concat(framework.get('name')).reduce(function reduce(memo, dependency) {\n      var extname = path.extname(dependency) || 'foreign';\n\n      memo[extname] = memo[extname] || [];\n      memo[extname].push(dependency);\n\n      return memo;\n    }, Object.create(null));\n  });\n\n  //\n  // Process and register the CSS/JS of all the pagelets.\n  //\n  async.waterfall([\n    async.apply(async.reduce, Object.keys(list), {}, prefab),\n    register\n  ], function completed(err, data) {\n    if (err) return done(err);\n\n    compiler.bigPipe(function browserified(err, buffer) {\n      if (err) return done(err);\n      debug('Finished creating browserify build');\n\n      var file = new File(framework.get('name'), {\n        dependency: true,\n        extname: '.js',\n        code: buffer\n      });\n\n      //\n      // Also register the file under the name of the fittings so\n      // it can also be loaded _without_ knowing the md5.\n      //\n      compiler.register(file);\n      compiler.register(file, true);\n\n      done(err, data);\n    });\n  });\n};\n\n/**\n * Find all required dependencies for given page constructor.\n *\n * @param {Page} page The initialized page.\n * @returns {Object}\n * @api private\n */\nCompiler.prototype.page = function find(page) {\n  var compiler = this\n    , assets = new Collection({ toString: this.html });\n\n  //\n  // The page is rendered in `sync` mode, so add all the required CSS files from\n  // the pagelet to the head of the page.\n  //\n  if (!('.css' in page._dependencies)) page._dependencies['.css'] = [];\n  if ('sync' === page.mode) page._enabled.forEach(function enabled(pagelet) {\n    Array.prototype.push.apply(page._dependencies['.css'], compiler.pagelet(pagelet).css);\n  });\n\n  //\n  // Push dependencies into the page. JS is pushed as extension after CSS,\n  // still adheres to the CSS before JS pattern, although it is less important\n  // in newer browser. See http://stackoverflow.com/questions/9271276/ for more\n  // details. Foreign extensions are added last to allow unidentified files to\n  // be included if possible.\n  //\n  preprocess.extensions.concat('.js', 'foreign').forEach(function map(type) {\n    if (!(type in page._dependencies)) return;\n\n    page._dependencies[type].forEach(function each(dependency) {\n      if (compiler.http(dependency)) {\n        return assets.push(new File(dependency, {\n          extname: compiler.type(dependency),\n          dependency: true,\n          external: true\n        }));\n      }\n\n      dependency = compiler.resolve(dependency);\n      if (!dependency) return;\n\n      assets.push(compiler.buffer[dependency]);\n    });\n  });\n\n  return assets;\n};\n\n/**\n * Check if the path is a http(s) url.\n *\n * @param {String} filepath Url to file.\n * @return {Boolean}\n * @api private\n */\nCompiler.prototype.http = function http(filepath) {\n  return /^(http:|https:)?\\/\\//.test(filepath);\n};\n\n/**\n * Generate HTML.\n *\n * @param {String} file The filename that needs to be added to a DOM.\n * @returns {String} A correctly wrapped HTML tag.\n * @api private\n */\nCompiler.prototype.html = function html(file) {\n  switch (file.extname) {\n    case '.css': return '<link rel=stylesheet href=\"'+ file.location +'\" />';\n    case '.js': return '<script src=\"'+ file.location +'\"></script>';\n    default: return '';\n  }\n};\n\n/**\n * Resolve all dependencies to their hashed versions.\n *\n * @param {String} original The original file path.\n * @returns {String} The hashed version.\n * @api private\n */\nCompiler.prototype.resolve = function resolve(original) {\n  return this.alias[original] || false;\n};\n\n/**\n * A list of resources that need to be loaded for the given pagelet.\n *\n * @param {Pagelet} pagelet The initialized pagelet.\n * @returns {Object}\n * @api private\n */\nCompiler.prototype.pagelet = function find(pagelet) {\n  var error = this.resolve(pagelet.error)\n    , view = this.resolve(pagelet.view)\n    , frag = {}\n    , css = []\n    , js = [];\n\n  debug('Compiling data from pagelet %s/%s', pagelet.name, pagelet.id);\n\n  if (pagelet.js.length) js = js.concat(pagelet.js.map(this.resolve, this));\n  if (pagelet.css.length) css = css.concat(pagelet.css.map(this.resolve, this));\n  if (view) js.push(view);\n  if (error) js.push(error);\n\n  frag.css = css;               // Add the compiled css.\n  frag.js = js;                 // Add the required js.\n\n  return frag;\n};\n\n/**\n * Store the compiled files to disk. This a vital part of the compiler as we're\n * changing the file names every single time there is a change. But these files\n * can still be cached on the client and it would result in 404's and or broken\n * functionality.\n *\n * @param {File} file The file instance.\n * @api private\n */\nCompiler.prototype.save = function save(file) {\n  var directory = path.resolve(this.dir)\n    , pathname = this.pathname;\n\n  fs.writeFileSync(path.join(directory, file.location), file.buffer);\n\n  this.list = fs.readdirSync(directory).reduce(function reduce(memo, file) {\n    if (path.extname(file)) {\n      memo[pathname + file] = path.resolve(directory, file);\n    }\n\n    return memo;\n  }, {});\n\n  return this;\n};\n\n/**\n * Serve the file.\n *\n * @param {Request} req Incoming HTTP request.\n * @param {Response} res Outgoing HTTP response.\n * @returns {Boolean} The request is handled by the compiler.\n * @api private\n */\nCompiler.prototype.serve = function serve(req, res) {\n  var file = (this._compiler || this).buffer[req.uri.pathname];\n\n  if (!file) return undefined;\n\n  res.setHeader('Content-Type', file.type);\n  res.setHeader('Content-Length', file.length);\n  res.end(file.buffer);\n\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Compiler;\n","/home/travis/build/npmtest/node-npmtest-bigpipe/node_modules/bigpipe/lib/collection.js":"'use strict';\n\nvar fuse = require('fusing');\n\n/**\n * Collection of files.\n *\n * @Constructor\n * @param {Object} options\n * @api public\n */\nfunction Collection(options) {\n  options = options || {};\n\n  this.fuse();\n  this.readable('stack', []);\n\n  //\n  // Only use the toString of options if it was explicitly provided, otherwise\n  // this would default to the toString of the options object.\n  //\n  if (options.hasOwnProperty('toString')) {\n    this.writable('_toString', options.toString);\n  }\n\n  this.concat(options.files);\n}\n\n//\n// Fuse collection with extendible.\n//\nfuse(Collection);\n\n/**\n * Push the file in the collection.\n *\n * @param {File} file\n * @return {Collection} fluent interface\n * @api public\n */\nCollection.readable('push', function push(file) {\n  if (!this.isFile(file) || ~this.stack.indexOf(file)) return this;\n  this.stack.push(file);\n\n  return this;\n});\n\n/**\n * JSON stringify by exposing locations of each File in the collection.\n *\n * @return {Array} all files in the collection\n * @api private\n */\nCollection.readable('toJSON', function toJSON() {\n  return this.stack.map(function map(file) {\n    return file.location;\n  });\n});\n\n/**\n * Concat another collection or file.\n *\n * @param {Collection|File} collection\n * @return {Collection} fluent interface\n * @api public\n */\nCollection.readable('concat', function concat(collection) {\n  if (this.isFile(collection)) this.push(collection);\n  else if (collection instanceof Collection) collection.stack.forEach(this.push, this);\n\n  return this;\n});\n\n/**\n * Check if the provided object is of type File.\n *\n * @return {Boolean}\n * @api private\n */\nCollection.readable('isFile', function (file) {\n  return !!(file && file.constructor && 'File' === file.constructor.name);\n});\n\n/**\n * Getter and Setter logic around providing a method that will be used toString\n * the Files in the Collection.\n *\n * @type {Function}\n * @api public\n */\nCollection.set('toString', function get() {\n  var collection = this;\n\n  return function toString() {\n    return collection.stack.reduce(function stringify(memo, file) {\n      return memo + collection._toString(file);\n    }, '');\n  };\n}, function set(method) {\n  if ('function' !== typeof method) return;\n  this._toString = method;\n});\n\n//\n// Expose the Collection constructor.\n//\nmodule.exports = Collection;","/home/travis/build/npmtest/node-npmtest-bigpipe/node_modules/bigpipe/lib/file.js":"'use strict';\n\nvar crypto = require('crypto')\n  , fuse = require('fusing')\n  , path = require('path');\n\n/**\n * Simple representation of a single file.\n *\n * @constructor\n * @param {String} filepath Absolute path to file.\n * @param {Object} options Set of options\n *\n * Available options:\n *  - aliases {String|Array} absolute (alternative) path(s) to the source.\n *  - extname {String} extension of the file.\n *  - dependency {Boolean} File is page level dependency.\n *  - code {Buffer} The contents of the file.\n *  - external {Boolean} File is hosted externally.\n *\n * @api public\n */\nfunction File(filepath, options) {\n  this.fuse();\n\n  options = options || {};\n  options.code = options.code || '';\n  options.extname = options.extname || '.js';\n  options.external = options.external || false;\n  options.dependency = options.dependency || false;\n\n  filepath = (filepath || '').replace(path.extname(filepath), '');\n\n  //\n  // Normalize aliasses. File can have multiple aliases, for example due to\n  // symlinked content. Aliases will be used by compiler.register\n  //\n  options.aliases = options.aliases || filepath;\n  options.aliases = Array.isArray(options.aliases)\n    ? options.aliases\n    : [ options.aliases ];\n\n  this.readable('enumerable', File.predefine(this, {\n    enumerable: true,\n    writable: true\n  }));\n\n  this.writable('code');                               // Actual code.\n  this.writable('buffer');                             // Buffer of code.\n  this.writable('_events');                            // EventEmitter 3.\n  this.writable('aliases', options.aliases);           // Absolute paths to source.\n\n  this.enumerable('length');                           // Buffer length.\n  this.enumerable('hash', null);                       // Hashed code representation.\n  this.enumerable('pagelets', []);                     // List of pagelets.\n  this.enumerable('filepath', filepath);               // Absolute path to file.\n  this.enumerable('extname', options.extname);         // File extension.\n  this.enumerable('external', options.external);       // File is hosted externally.\n\n  this.readable('dependency', options.dependency);     // File is page dependency.\n  this.readable('type', this.mime[this.extname]);      // The content-type.\n\n  //\n  // Process the content of the file if provided.\n  //\n  this.hash = this.encrypt(options.code);\n  this.set(options.code);\n}\n\nfuse(File, require('eventemitter3'));\n\n/**\n * Expose distributed location of the File.\n *\n * @return {String} file location.\n * @api public\n */\nFile.readable('location', {\n  enumerable: false,\n  get: function get() {\n    if (this.external) return this.filepath + this.extname;\n    return '/' + this.hash + this.extname;\n  }\n}, true);\n\n/**\n * Expose original location of the File.\n *\n * @return {String} original file location.\n * @api public\n */\nFile.readable('origin', {\n  enumerable: false,\n  get: function get() {\n    if (!this.filepath) return;\n    return '/' + this.filepath + this.extname;\n  }\n}, true);\n\n/**\n * Update the content of the file, convert to Buffer if required and update length.\n *\n * @param {Buffer|String} content Content of the file.\n * @returns {File} fluent interface\n * @api private\n */\nFile.readable('set', function set(content) {\n  this.code = content.toString('utf-8');\n\n  //\n  // Append async loading class to CSS\n  //\n  if (this.is('css')) {\n    content = this.append(content, this.hash);\n  }\n\n  this.buffer = Buffer.isBuffer(content) ? content : new Buffer(content);\n  this.length = this.buffer.length;\n\n  return this;\n});\n\n/**\n * Get the orginal content, either the buffer or the code.\n *\n * @param {Boolean} readable true will return readable code, false the Buffer\n * @return {String} content\n * @api public\n */\nFile.readable('get', function get(readable) {\n  return readable ? this.code : this.buffer;\n});\n\n/**\n * Update the CSS with a selector that contains the filename which is\n * required for async loading of CSS.\n *\n * @param {String} content CSS\n * @param {String} hash Optional hashed representation of the file\n * @returns {String} CSS content with selector appended\n * @api public\n */\nFile.readable('append', function append(content, hash) {\n  return [\n    content,\n    '#_',\n    hash || this.hash,\n    ' { height: 42px }'\n  ].join('');\n});\n\n/**\n * Create a hash of the code which can be used as filename. This allows us to\n * aggressively cache the data.\n *\n * @param {String} code The code that is send to the client.\n * @returns {String} hash representation of the code.\n * @api private\n */\nFile.readable('encrypt', function encrypt(code) {\n  return crypto.createHash('sha1').update(code).digest('hex').toString('hex');\n});\n\n/**\n * Check if the file is of the provided type.\n *\n * @param {String} type part of the extension of the file.\n * @returns {Boolean}\n * @api private\n */\nFile.readable('is', function is(type) {\n  if (type.charAt(0) !== '.') type = '.' + type;\n  return this.extname === type;\n});\n\n/**\n * Add file to the list of aliases.\n *\n * @param {String} filepath\n * @return {File} fluent interface\n * @api public\n */\nFile.readable('alias', function alias(filepath) {\n  if (!~this.aliases.indexOf(filepath)) this.aliases.push(filepath);\n  return this;\n});\n\n/**\n * Small mime lookup table.\n *\n * @type {Object}\n * @private\n */\nFile.readable('mime', {\n  '.js': 'text/javascript; charset=utf-8',\n  '.css': 'text/css; charset=utf-8'\n});\n\n//\n// Expose the module interface.\n//\nmodule.exports = File;\n","/home/travis/build/npmtest/node-npmtest-bigpipe/node_modules/bigpipe.js/index.js":"'use strict';\n\nvar Fittings = require('fittings')\n  , join = require('path').join\n  , fs = require('fs');\n\n/**\n * Read files out of our instructions directory.\n *\n * @param {String} file Filename that we should read.\n * @returns {String}\n * @api private\n */\nfunction read(file) {\n  return fs.readFileSync(join(__dirname, 'instructions', file), 'utf-8');\n}\n\n//\n// Expose the fittings definition for the BigPipe.js client library which\n// processes all the magic.\n//\nFittings.extend({\n  //\n  // Required name to identify the framework being pushed into Fittings.\n  //\n  name: 'bigpipe',\n\n  //\n  // The template that is flushed to the client every single time a pagelet is\n  // ready to write it's output. We split it so we can minify all the things.\n  //\n  fragment: read('fragment.html').split('\\n').join(''),\n\n  //\n  // Library bootstrap which will be passed into the bootstrap pagelet.\n  //\n  bootstrap: read('bootstrap.html'),\n\n  //\n  // Wrapping template to introduce client-side templates.\n  //\n  template: read('template.js'),\n\n  //\n  // Wrapping template to introduce plugin client code.\n  //\n  plugin: read('plugin.js'),\n\n  //\n  // Reference(s) to the library files that should be loaded.\n  //\n  library: require.resolve('./bigpipe.js'),\n\n  //\n  // Additional plugins.\n  //\n  use: {\n    css: {\n      server: function server(bigpipe) {\n        var compiler = bigpipe._compiler;\n\n        compiler.on('assembly', compiler.namespace);\n      }\n    }\n  }\n}).on(module);\n","/home/travis/build/npmtest/node-npmtest-bigpipe/node_modules/bigpipe/middleware/defaults.js":"'use strict';\n\nvar url = require('url');\n\n/**\n * A small middleware layer which is ran before everything else to add some\n * silly connect based middleware defaults so they can also be used in BigPipe.\n *\n * @type {Function}\n * @api public\n */\nmodule.exports = function defaults(req, res) {\n  req.uri = req.uri || url.parse(req.url, true);\n  req.query = req.query || req.uri.query;\n  req.originalUrl = req.url;\n};\n"}